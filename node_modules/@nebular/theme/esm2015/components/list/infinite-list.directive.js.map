{"version":3,"file":"infinite-list.directive.js","sourceRoot":"","sources":["../../../../../../.ng_build/theme/components/list/infinite-list.directive.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Directive,\n  Input,\n  HostListener,\n  ElementRef,\n  EventEmitter,\n  Output,\n  OnDestroy,\n  AfterViewInit,\n  ContentChildren,\n  QueryList,\n} from '@angular/core';\nimport { Observable, forkJoin, of as observableOf, interval, timer, Subject } from 'rxjs';\nimport { filter, switchMap, map, takeUntil, take } from 'rxjs/operators';\nimport { convertToBoolProperty, NbBooleanInput } from '../helpers';\nimport { NbLayoutScrollService } from '../../services/scroll.service';\nimport { NbLayoutRulerService } from '../../services/ruler.service';\nimport { NbListItemComponent } from './list.component';\n\nexport class NbScrollableContainerDimentions {\n  scrollTop: number;\n  scrollHeight: number;\n  clientHeight: number;\n}\n\n/**\n * Infinite List Directive\n *\n * ```html\n *  <nb-list nbInfiniteList [threshold]=\"500\" (bottomThreshold)=\"loadNext()\">\n *    <nb-list-item *ngFor=\"let item of items\"></nb-list-item>\n *  </nb-list>\n * ```\n *\n * @stacked-example(Simple infinite list, infinite-list/infinite-list-showcase.component)\n *\n * Directive will notify when list scrolled up or down to a given threshold.\n * By default it listen to scroll of list on which applied, but also can be set to listen to window scroll.\n *\n * @stacked-example(Scroll modes, infinite-list/infinite-list-scroll-modes.component)\n *\n * To improve UX of infinite lists, it's better to keep current page in url,\n * so user able to return to the last viewed page or to share a link to this page.\n * `nbListPageTracker` directive will help you to know, what page user currently viewing.\n * Just put it on a list, set page size and it will calculate page that currently in viewport.\n * You can [open the example](example/infinite-list/infinite-news-list.component)\n * in a new tab to check out this feature.\n *\n * @stacked-example(Infinite list with pager, infinite-list/infinite-news-list.component)\n *\n * @stacked-example(Infinite list with placeholders at the top, infinite-list/infinite-list-placeholders.component)\n *\n */\n@Directive({\n  selector: '[nbInfiniteList]',\n})\nexport class NbInfiniteListDirective implements AfterViewInit, OnDestroy {\n\n  private destroy$ = new Subject<void>();\n  private lastScrollPosition;\n  windowScroll = false;\n  private get elementScroll() {\n    return !this.windowScroll;\n  }\n\n  /**\n   * Threshold after which event load more event will be emited.\n   * In pixels.\n   */\n  @Input()\n  threshold: number;\n\n  /**\n   * By default component observes list scroll position.\n   * If set to `true`, component will observe position of page scroll instead.\n   */\n  @Input()\n  set listenWindowScroll(value) {\n    this.windowScroll = convertToBoolProperty(value);\n  }\n  static ngAcceptInputType_listenWindowScroll: NbBooleanInput;\n\n  /**\n   * Emits when distance between list bottom and current scroll position is less than threshold.\n   */\n  @Output()\n  bottomThreshold = new EventEmitter(true);\n\n  /**\n   * Emits when distance between list top and current scroll position is less than threshold.\n   */\n  @Output()\n  topThreshold = new EventEmitter(true);\n\n  @HostListener('scroll')\n  onElementScroll() {\n    if (this.elementScroll) {\n      this.checkPosition(this.elementRef.nativeElement);\n    }\n  }\n\n  @ContentChildren(NbListItemComponent) listItems: QueryList<NbListItemComponent>;\n\n  constructor(\n    private elementRef: ElementRef,\n    private scrollService: NbLayoutScrollService,\n    private dimensionsService: NbLayoutRulerService,\n  ) {}\n\n  ngAfterViewInit() {\n    this.scrollService.onScroll()\n      .pipe(\n        filter(() => this.windowScroll),\n        switchMap(() => this.getContainerDimensions()),\n        takeUntil(this.destroy$),\n      )\n      .subscribe(dimentions => this.checkPosition(dimentions));\n\n    this.listItems.changes\n      .pipe(\n        // For some reason, changes are emitted before list item removed from dom,\n        // so dimensions will be incorrect.\n        // Check every 50ms for a second if dom and query are in sync.\n        // Once they synchronized, we can get proper dimensions.\n        switchMap(() => interval(50).pipe(\n          filter(() => this.inSyncWithDom()),\n          take(1),\n          takeUntil(timer(1000)),\n        )),\n        switchMap(() => this.getContainerDimensions()),\n        takeUntil(this.destroy$),\n      )\n      .subscribe(dimentions => this.checkPosition(dimentions));\n\n      this.getContainerDimensions().subscribe(dimentions => this.checkPosition(dimentions));\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n\n  checkPosition({ scrollHeight, scrollTop, clientHeight }: NbScrollableContainerDimentions) {\n    const initialCheck = this.lastScrollPosition == null;\n    const manualCheck = this.lastScrollPosition === scrollTop;\n    const scrollUp = scrollTop < this.lastScrollPosition;\n    const scrollDown = scrollTop > this.lastScrollPosition;\n    const distanceToBottom = scrollHeight - scrollTop - clientHeight;\n\n    if ((initialCheck ||  manualCheck || scrollDown) && distanceToBottom <= this.threshold) {\n      this.bottomThreshold.emit();\n    }\n    if ((initialCheck || scrollUp) && scrollTop <= this.threshold) {\n      this.topThreshold.emit();\n    }\n\n    this.lastScrollPosition = scrollTop;\n  }\n\n  private getContainerDimensions(): Observable<NbScrollableContainerDimentions> {\n    if (this.elementScroll) {\n      const { scrollTop, scrollHeight, clientHeight } = this.elementRef.nativeElement;\n      return observableOf({ scrollTop, scrollHeight, clientHeight });\n    }\n\n    return forkJoin([this.scrollService.getPosition(), this.dimensionsService.getDimensions()])\n      .pipe(\n          map(([scrollPosition, dimensions]) => ({\n            scrollTop: scrollPosition.y,\n            scrollHeight: dimensions.scrollHeight,\n            clientHeight: dimensions.clientHeight,\n          })),\n      );\n  }\n\n  private inSyncWithDom(): boolean {\n    return this.elementRef.nativeElement.children.length === this.listItems.length;\n  }\n}\n"]}