{"version":3,"file":"overlay-position.d.ts","sources":["overlay-position.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { ElementRef } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { NbConnectedPosition, NbFlexibleConnectedPositionStrategy, NbOverlayPositionBuilder, NbOverlayRef, NbPositionStrategy } from './mapping';\nimport { NbPlatform } from '../platform/platform-service';\nimport { NbOverlayContainerAdapter } from '../adapter/overlay-container-adapter';\nimport { NbViewportRulerAdapter } from '../adapter/viewport-ruler-adapter';\nimport { NbGlobalLogicalPosition } from './position-helper';\nimport { GlobalPositionStrategy } from '@angular/cdk/overlay';\nexport declare type NbAdjustmentValues = 'noop' | 'clockwise' | 'counterclockwise' | 'vertical' | 'horizontal';\nexport declare enum NbAdjustment {\n    NOOP = \"noop\",\n    CLOCKWISE = \"clockwise\",\n    COUNTERCLOCKWISE = \"counterclockwise\",\n    VERTICAL = \"vertical\",\n    HORIZONTAL = \"horizontal\"\n}\nexport declare type NbPositionValues = 'top' | 'bottom' | 'left' | 'right' | 'start' | 'end' | 'top-end' | 'top-start' | 'bottom-end' | 'bottom-start' | 'end-top' | 'end-bottom' | 'start-top' | 'start-bottom';\nexport declare enum NbPosition {\n    TOP = \"top\",\n    BOTTOM = \"bottom\",\n    LEFT = \"left\",\n    RIGHT = \"right\",\n    START = \"start\",\n    END = \"end\",\n    TOP_END = \"top-end\",\n    TOP_START = \"top-start\",\n    BOTTOM_END = \"bottom-end\",\n    BOTTOM_START = \"bottom-start\",\n    END_TOP = \"end-top\",\n    END_BOTTOM = \"end-bottom\",\n    START_TOP = \"start-top\",\n    START_BOTTOM = \"start-bottom\"\n}\n/**\n * The main idea of the adjustable connected strategy is to provide predefined set of positions for your overlay.\n * You have to provide adjustment and appropriate strategy will be chosen in runtime.\n * */\nexport declare class NbAdjustableConnectedPositionStrategy extends NbFlexibleConnectedPositionStrategy implements NbPositionStrategy {\n    protected _position: NbPosition;\n    protected _offset: number;\n    protected _adjustment: NbAdjustment;\n    protected appliedPositions: {\n        key: NbPosition;\n        connectedPosition: NbConnectedPosition;\n    }[];\n    readonly positionChange: Observable<NbPosition>;\n    attach(overlayRef: NbOverlayRef): void;\n    apply(): void;\n    position(position: NbPosition): this;\n    adjustment(adjustment: NbAdjustment): this;\n    offset(offset: number): this;\n    protected applyPositions(): void;\n    protected createPositions(): NbPosition[];\n    protected persistChosenPositions(positions: NbPosition[]): void;\n    protected reorderPreferredPositions(positions: NbPosition[]): NbPosition[];\n    protected mapToLogicalPosition(position: NbPosition): NbPosition;\n}\nexport declare class NbGlobalPositionStrategy extends GlobalPositionStrategy {\n    position(position: NbGlobalLogicalPosition): this;\n}\nexport declare class NbPositionBuilderService {\n    protected document: any;\n    protected viewportRuler: NbViewportRulerAdapter;\n    protected platform: NbPlatform;\n    protected positionBuilder: NbOverlayPositionBuilder;\n    protected overlayContainer: NbOverlayContainerAdapter;\n    constructor(document: any, viewportRuler: NbViewportRulerAdapter, platform: NbPlatform, positionBuilder: NbOverlayPositionBuilder, overlayContainer: NbOverlayContainerAdapter);\n    global(): NbGlobalPositionStrategy;\n    connectedTo(elementRef: ElementRef): NbAdjustableConnectedPositionStrategy;\n}\n"]}